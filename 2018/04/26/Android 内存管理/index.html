<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="何夜无月，何处无竹柏，但少闲人，如吾两人者耳"><title>Android 内存管理 | 学而时习之</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android 内存管理</h1><a id="logo" href="/.">学而时习之</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android 内存管理</h1><div class="post-meta">Apr 26, 2018<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><p>ART和Dalvik虚拟机使用页式和内存映射（memory-mapping）的方式管理内存。这意味着应用程序修改的任何内存（无论是通过分配新对象还是使用的页面）仍然驻留在RAM中，并且无法移除页面。唯一释放内存的方式是：首先，释放APP持有的对象的引用，然后使用垃圾收集器回收这部分内存。有一个例外，如果系统想要使用内存，系统会将未经修改而映射的文件（例如，代码）置换出内存。</p>
<p>本文将介绍Android如何管理进程和内存分配。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>内存管理环境（ART或Dalvik虚拟机）会跟踪每个内存的分配情况。一旦确定一个内存块不再被应用程序使用，垃圾收集器会自动释放这块内存。这个过程不需要开发人员干预。这种自动回收内存管理环境中无用内存的机制，被称为垃圾回收。垃圾回收有两个目的：找到在以后程序运行中不需要的对象；回收这些对象占用的内存。</p>
<p>Android内存堆是分代的。它会根据分配对象的预期寿命和大小，分配到不同的年代中。例如，刚分配的对象属于年轻代（Young  generation）。当一个对象存活到一定时间，会被转移到老年代（Older generation），紧跟着是永久代（permanent  generation）。</p>
<p>每个年代堆都有自己分配内存的上限。当每个年代堆达到内存上线时，系统会启动垃圾回收机制释放内存。垃圾回收持续的时间取决于它正在回收哪一代的对象，以及每代有多少活动对象。</p>
<p>尽管垃圾回收的执行过程很快，它还是会影响你的APP的性能。你无法控制垃圾回收发生的时间。系统有一组策略用以确定何时进行垃圾回收。当满足这些策略的标准时，系统将停止正在执行的进程，然后开始回收内存。如果垃圾收集发生在程序正在处理密集计算时（如动画或音乐回放），则会增加处理时间。时间的增长可能会造成应用程序中代码的执行时间超过16ms的阈值，从而使界面卡顿。</p>
<p>此外，你的代码在执行过程中，有可能会导致频繁GC，或者使GC持续较长时间。例如，在执行动画的每个帧中，在for循环内部分配多个对象，则这些对象可能会污染内存堆。此时，垃圾收集器会执行多个垃圾回收事件，并且会降低应用程序的性能。</p>
<p>更多关于垃圾收集器的信息请参考wiki。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>为了使其在RAM中所需的所有内容都符合要求，Android可以跨进程共享RAM内存页。 它可以通过以下方式进行：</p>
<pre><code>* 每个应用程序进程都是由Zygote进程孵化出来的。当系统启动并加装公共框架和资源时，Zygote进程会启动。在开启新的应用程序进程时，首先，系统会创建Zygote进程，然后，在新的进程中加装并运行应用程序代码。这个方法允许所有应用程序进程共享大部分的RAM 内存页。
* 大部分静态数据是内存映射到进程。内存映射可以在进程间共享数据，也可以按需置换出内存。常见的静态数据包括：Dalvik代码（通过将其放置在用于直接映射的预链接.odex文件中），应用程序资源（通过将资源表设计为可以进行mmap的结构以及通过对齐APK的zip文件） ，以及传统的项目元素，如.so文件中的native代码。
* 在很多地方，Android使用显式的方式分配共享内存区域（使用ashmem或gralloc）共享同一个动态内存块。例如，Window surface使用应用程序和屏幕合成器之间的共享内存，而游标缓冲区（cursor buffer）使用ContentProvider和客户端之间的共享内存。
</code></pre><p>由于共享内存的广泛使用，需要注意你的应用使用了多少内存。查看内存的占用率参考 Investigating Your RAM Usage.</p>
<h2 id="分配和回收APP内存"><a href="#分配和回收APP内存" class="headerlink" title="分配和回收APP内存"></a>分配和回收APP内存</h2><p>Dalvik堆大小被控制在每个应用程序进程的单个虚拟内存范围内。 这定义了逻辑堆大小，可以根据需要增长，但不能超过系统为每个应用程序定义的上限。</p>
<p>堆的逻辑大小与堆使用的物理内存大小不同。当查看你的应用程序的堆时，Android会计算Proportional Set Size (PSS, 按比例分配内存)值。::该值表示与其他进程共享的脏页面和干净页面 - 但数量与多少应用程序共享该RAM成正比。::系统将总的PSS值看作应用所占的物理内存。</p>
<p>Dalvik堆没有压缩逻辑堆的大小，这意味着Android系统不会整理堆用以关闭空间。当堆的末尾有未使用的空间时，Android只能收缩逻辑堆的大小。然而，系统仍可以减少堆使用的物理内存。执行垃圾回收后，Dalvik遍历堆并找到未使用的页面，然后使用<code>madvise</code>将这些页面返回给内核。因此，大块的配对分配和释放应该导致回收所有（或几乎所有）使用的物理内存。但是，回收小的内存块的效率可能会比较低，因为小内存块所在的页面可能与尚未释放的对象所共享。</p>
<blockquote>
<p>The madvise() system call is used to give advice or directions to the kernel about the address range beginning at  improve system or application performance.<br>Initially, the system call supported a set of “conventional” advice values, which are also available on several other (Note, though, that madvise() is not specified in POSIX.) Subsequently, a number of Linux-specific advice values have been added.  </p>
</blockquote>
<h2 id="对APP内存的限制"><a href="#对APP内存的限制" class="headerlink" title="对APP内存的限制"></a>对APP内存的限制</h2><p>为了维护系统多任务的环境，Android系统对每个应用程序所占堆的大小作了严格限制。每个APP所占堆大小取决于手机的内存大小。如果你的APP所占内存达到上限，且再为对象申请更多内存，就会导致OOM。</p>
<p>在某些情况下（例如，设置缓存区的大小），你可能需要确定在当前手机上最多可分配多少内存。可以通过<code>getMemoryClass()</code>这个方法查询应用程序可占内存上限。这个方法会返回一个int值，单位是Mb，表示每个应用程序可获得的内存大小。</p>
<h2 id="多个APP间的切换"><a href="#多个APP间的切换" class="headerlink" title="多个APP间的切换"></a>多个APP间的切换</h2><p>当用户在不同应用程序间切换时，Android会将不在前台的应用程序（例如，对用户不可见或者运行在前台的服务）缓存到LRU Cache中。例如，当启动一个应用时，系统会为它创建一个进程；但当用户离开该应用时，系统不会销毁该应用进程，而是将这个进程放入缓存。如果用户稍后返回这个应用，系统就会复用这个进程，从而使应用间切换更流程。</p>
<p>如果你的应用程序的进程在缓存中并持有目前不需要的内存，那么你的应用程序即使在用户不使用它的情况下也会影响系统的整体性能。由于系统内存不足，系统会销毁在缓存中最近最少使用的进程。系统也会考虑销毁占用内存最多的进程。</p>
<p>Note: 当系统开始销毁LRU Cache中的进程时，它是自底向上的。系统也会考虑销毁占用内存最多的应用程序进程。你的应用在LRU Cache中占用的内存越少，越不会被系统销毁掉，并且可以更快的启动。</p>
<p>#Android 性能优化#</p>
</div><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/性能优化/">性能优化</a><a href="/tags/内存/">内存</a></div><div class="post-nav"><a class="pre" href="/2018/04/28/管理应用程序内存/">管理应用程序内存</a><a class="next" href="/2018/04/20/Android 性能优化 之 StrictMode/">Android 性能优化 之 StrictMode</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://nxiangbo.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/命令行工具/">命令行工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/适配/" style="font-size: 15px;">适配</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/strictmode/" style="font-size: 15px;">strictmode</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/UI/" style="font-size: 15px;">UI</a> <a href="/tags/Java虚拟机/" style="font-size: 15px;">Java虚拟机</a> <a href="/tags/内存模型/" style="font-size: 15px;">内存模型</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/资源打包/" style="font-size: 15px;">资源打包</a> <a href="/tags/aapt2/" style="font-size: 15px;">aapt2</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/aapt2 工具介绍/">aapt2 工具介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/Java 反射机制/">Java 反射机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/Android 屏幕适配/">Android 屏幕适配</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/25/Java类加载机制/">Java类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/Java内存模型/">Java内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/14/Java虚拟机垃圾回收机制/">Java虚拟机垃圾回收机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/14/Java 虚拟机运行时数据区/">Java 虚拟机运行时数据区</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/优化APP启动时间/">优化APP启动时间</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/管理应用程序内存/">管理应用程序内存</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/26/Android 内存管理/">Android 内存管理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">学而时习之.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>